[
  {
    "objectID": "preface.html",
    "href": "preface.html",
    "title": "Valedictory of Enrichment",
    "section": "",
    "text": "Engaged in bioinformatics analysis for over five years, I’ve come to realize that no matter which methods are used, understanding the function of identified genes inevitably requires enrichment analysis. It’s like a gateway that you can never avoid. Behind this gateway lie countless biological insights, waiting to be discovered. I will never forget the first time I encountered the clusterProfiler package four and a half years ago. Rich in features, timelessly innovative, concise, and powerful, it has been my guiding light among R packages—a true favorite in my analyses.\nAbout two and a half years ago, after learning to develop R packages myself, I always wanted to create a lightweight replication of such tools. However, the initial attempts resulted in packages with ever-increasing dependencies, making them cumbersome and inefficient, the very opposite of my intentions.\nAfter numerous analysis projects, I’ve come to a deeper understanding: the wealth of information from high-throughput sequencing often stands at odds with the simplicity of a single chart. Most top-tier journal articles today feature highly customized figures tailored to highlight important findings. In other words, the complexity of biology means that default plots generated by any tool might fail to convey all the underlying information. Default dot plots, for instance, might even lead you to overlook subtle biological stories hidden in the data.\nMoreover, most of the time, you need to report results to supervisors or clients. Busy with experiments, there’s often no time for custom visualizations, leaving you reliant on default plots. Over the years, I’ve pondered how to resolve this paradox—until I discovered the gt package developed by Posit. That’s when I realized: the time has come.\nTwo and a half years later, I’ve matured significantly, gaining a deeper understanding of R’s underlying logic and embracing the philosophy of “less is more” and “bad is good.” Now, it’s time to develop EnrichGT, which I consider my farewell gift to R. It’s a tool I take pride in—one that reveals the beauty of statistics—but life moves on. My research group is facing uncertain times, and the road ahead is unclear. Perhaps some things must inevitably come to an end.\nIn the wave of advancements in Python, machine learning, and artificial intelligence, it feels like the time to explore unknown horizons—if I still have the chance, though such opportunities may no longer be guaranteed.\n\n\n\n Back to top"
  },
  {
    "objectID": "pkgfuns.html",
    "href": "pkgfuns.html",
    "title": "DESCRIPTION",
    "section": "",
    "text": "Type: Package\nPackage: EnrichGT\nTitle: EnrichGT - all in one enrichment analysis soluction\nVersion: 0.7.0\nAuthor: Zhiming Ye\nMaintainer: Zhiming Ye &lt;garnetcrow@hotmail.com&gt;\nDescription: Do biological enrichment analysis and parsing and clustering\n    enrichment result to insightful results in just ONE package\nLicense: GPL-V3\nURL: https://zhimingye.github.io/EnrichGT/\nDepends: \n    R (&gt;= 2.10)\nImports: \n    AnnotationDbi,\n    BiocManager,\n    cli,\n    dplyr,\n    fgsea,\n    fontawesome,\n    forcats,\n    ggplot2,\n    ggrepel,\n    glue,\n    GO.db,\n    grDevices,\n    gt,\n    Matrix,\n    methods,\n    parallel,\n    proxy,\n    qvalue,\n    RColorBrewer,\n    Rcpp,\n    reactome.db,\n    rlang,\n    scales,\n    stats,\n    stringr,\n    text2vec,\n    tibble,\n    umap,\n    utils,\n    xfun\nLinkingTo: \n    Rcpp\nConfig/testthat/edition: 3\nEncoding: UTF-8\nLazyData: true\nRoxygenNote: 7.3.2"
  },
  {
    "objectID": "pkgfuns.html#description-1",
    "href": "pkgfuns.html#description-1",
    "title": "DESCRIPTION",
    "section": "Description",
    "text": "Description\nConvert gene annotations from any keys to any keys"
  },
  {
    "objectID": "pkgfuns.html#usage",
    "href": "pkgfuns.html#usage",
    "title": "DESCRIPTION",
    "section": "Usage",
    "text": "Usage\nconvert_annotations_genes(genes, from_what, to_what, OrgDB)"
  },
  {
    "objectID": "pkgfuns.html#arguments",
    "href": "pkgfuns.html#arguments",
    "title": "DESCRIPTION",
    "section": "Arguments",
    "text": "Arguments\n\ngenes: gene vector\nfrom_what: input type (like “SYMBOL”,“ENTREZID”,“ENSEMBL”,“GENENAME”,…), keys should be supported by AnnotationDbi. Search for the help page of AnnotationDbi for further help.\nto_what: output type (like “SYMBOL”,“ENTREZID”,“ENSEMBL”,“GENENAME”,…), keys should be supported by AnnotationDbi. Search for the help page of AnnotationDbi for further help. Can be multiple items E.g. c(\"ENTREZID\",\"ENSEMBL\",\"GENENAME\")\nOrgDB: human = org.Hs.eg.db, mouse = org.Mm.eg.db, search BioConductor website for further help"
  },
  {
    "objectID": "pkgfuns.html#value",
    "href": "pkgfuns.html#value",
    "title": "DESCRIPTION",
    "section": "Value",
    "text": "Value\na data.frame"
  },
  {
    "objectID": "pkgfuns.html#description-2",
    "href": "pkgfuns.html#description-2",
    "title": "DESCRIPTION",
    "section": "Description",
    "text": "Description\nRead .gmt files. You can download them from https://www.gsea-msigdb.org/gsea/msigdb/human/collections.jsp WikiPathway database also provides pre-built GMT files (https://data.wikipathways.org/current/gmt/). In default they are recorded as ENTREZ IDs, so you need to provide proper species database (e.g. org.Hs.eg.db for human), to database_from_gmt function and EnrichGT will automatically convert ENTREZ IDs to gene symbols for enrichment analysis."
  },
  {
    "objectID": "pkgfuns.html#usage-1",
    "href": "pkgfuns.html#usage-1",
    "title": "DESCRIPTION",
    "section": "Usage",
    "text": "Usage\ndatabase_from_gmt(gmtfile, OrgDB = NULL, convert_2_symbols = T)"
  },
  {
    "objectID": "pkgfuns.html#arguments-1",
    "href": "pkgfuns.html#arguments-1",
    "title": "DESCRIPTION",
    "section": "Arguments",
    "text": "Arguments\n\ngmtfile: gmt file path\nOrgDB: Only need when converting genes, human = org.Hs.eg.db, mouse = org.Mm.eg.db, search BioConductor website for further help. Default is NULL.\nconvert_2_symbols: Force to convert numeric gene ids (as ENTREZIDs) to gene symbols"
  },
  {
    "objectID": "pkgfuns.html#author",
    "href": "pkgfuns.html#author",
    "title": "DESCRIPTION",
    "section": "Author",
    "text": "Author\ncited from https://github.com/YuLab-SMU/gson/blob/main/R/GMT.R . The further Cache system is written by Zhiming Ye."
  },
  {
    "objectID": "pkgfuns.html#value-1",
    "href": "pkgfuns.html#value-1",
    "title": "DESCRIPTION",
    "section": "Value",
    "text": "Value\ndata.frame"
  },
  {
    "objectID": "pkgfuns.html#description-3",
    "href": "pkgfuns.html#description-3",
    "title": "DESCRIPTION",
    "section": "Description",
    "text": "Description\nSee ?EnrichGT()"
  },
  {
    "objectID": "pkgfuns.html#usage-2",
    "href": "pkgfuns.html#usage-2",
    "title": "DESCRIPTION",
    "section": "Usage",
    "text": "Usage\negt_compare_groups(\n  obj.test,\n  obj.ctrl,\n  name.test = NULL,\n  name.ctrl = NULL,\n  ClusterNum = 15,\n  P.adj = 0.05,\n  force = F,\n  nTop = 10,\n  method = \"ward.D2\",\n  ...\n)"
  },
  {
    "objectID": "pkgfuns.html#arguments-2",
    "href": "pkgfuns.html#arguments-2",
    "title": "DESCRIPTION",
    "section": "Arguments",
    "text": "Arguments\n\nobj.test: the enriched object from tested group. WARNING: obj.test and obj.ctrl should come from same database (e.g. GO Biological Process(GOBP)).\nobj.ctrl: the enriched object from control group. WARNING: obj.test and obj.ctrl should come from same database (e.g. GO Biological Process(GOBP)).\nname.test: optional, the name of the testing group. If is NULL, the object name of obj.test will be used.\nname.ctrl: optional, the name of the control group. If is NULL, the object name of obj.ctrl will be used.\nClusterNum: how many cluster will be clustered\nP.adj: p.adjust cut-off. To avoid slow visualization, you can make stricter p-cut off.\nforce: ignore all auto-self-checks, which is useful\nnTop: keep n top items according to p-adj in each cluster.\nmethod: the agglomeration method to be used. This should be (an unambiguous abbreviation of) one of “ward.D”, “ward.D2”, “single”, “complete”, “average” (= UPGMA), “mcquitty” (= WPGMA), “median” (= WPGMC) or “centroid” (= UPGMC).\n...: Others options."
  },
  {
    "objectID": "pkgfuns.html#details",
    "href": "pkgfuns.html#details",
    "title": "DESCRIPTION",
    "section": "Details",
    "text": "Details\nExecute obj.test VS obj.ctrl tests, showing pathway overlaps (or differences) and meta-gene modules of test group and control group. Supports ORA and GSEA results (enriched object or data.frame). !WARNING!: obj.test and obj.ctrl should come from same database (e.g. GO Biological Process(GOBP))."
  },
  {
    "objectID": "pkgfuns.html#author-1",
    "href": "pkgfuns.html#author-1",
    "title": "DESCRIPTION",
    "section": "Author",
    "text": "Author\nZhiming Ye"
  },
  {
    "objectID": "pkgfuns.html#value-2",
    "href": "pkgfuns.html#value-2",
    "title": "DESCRIPTION",
    "section": "Value",
    "text": "Value\nList containing multiple EnrichGT_obj objects. The List contains objects with overlapped enriched terms, unique enrich terms."
  },
  {
    "objectID": "pkgfuns.html#description-4",
    "href": "pkgfuns.html#description-4",
    "title": "DESCRIPTION",
    "section": "Description",
    "text": "Description\nORA is a statistical method used to identify biological pathways or gene sets that are significantly enriched in a given list of genes (e.g., differentially expressed genes). The method compares the proportion of genes in the target list that belong to a specific category (e.g., pathways, GO terms) to the expected proportion in the background gene set. To accelerate the computation in ORA analysis, EnrichGT have implemented a function that leverages C++ for high-performance computation. The core algorithm utilizes hash tables for efficient lookup and counting of genes across categories. Also It provides multi-Core parallel calculation by package parallel."
  },
  {
    "objectID": "pkgfuns.html#usage-3",
    "href": "pkgfuns.html#usage-3",
    "title": "DESCRIPTION",
    "section": "Usage",
    "text": "Usage\nres &lt;- egt_enrichment_analysis(genes = DEGtable$Genes,\ndatabase = database_GO_BP())\n\nres &lt;- egt_enrichment_analysis(genes = c(\"TP53\",\"CD169\",\"CD68\",\"CD163\",...),\ndatabase = database_GO_ALL())\n\nres &lt;- egt_enrichment_analysis(genes = c(\"TP53\",\"CD169\",\"CD68\",\"CD163\",...),\ndatabase = database_from_gmt(\"MsigDB_Hallmark.gmt\"))\n\nres &lt;- egt_enrichment_analysis(list(Macrophages=c(\"CD169\",\"CD68\",\"CD163\"),\nFibroblast=c(\"COL1A2\",\"COL1A3\"),...),\n database = database_from_gmt(\"panglaoDB.gmt\"))"
  },
  {
    "objectID": "pkgfuns.html#arguments-3",
    "href": "pkgfuns.html#arguments-3",
    "title": "DESCRIPTION",
    "section": "Arguments",
    "text": "Arguments\n\ngenes: a vector of gene ids like c(\"TP53\",\"CD169\",\"CD68\",\"CD163\"...).If you have genes from multiple source or experiment group, you can also pass a list with gene ids in it. For Example , list(Macrophages=c(\"CD169\",\"CD68\",\"CD163\"),Fibroblast=c(\"COL1A2\",\"COL1A3)).The genes should be match in the second param database’s gene column. For example, if database provides Ensembl IDs, you should input Ensembl IDs. But in default databases provided by EnrichGT is gene symbols.\ndatabase: a database data frame, can contain 3 columns (ID, Pathway_Name, Genes) or just 2 columns (Pathway_Name, Genes). You can read a data frame and pass it through this or run database_GO_CC() to get them, see example.You can run database_GO_CC() to see an example.The ID column is not necessary. EnrichGT contains several databases, functions about databases are named starts with database_..., like database_GO_BP() or database_Reactome().The default gene in each database EnrichGT provided to input is GENE SYMBOL (like TP53, not 1256 or ENSG…), not ENTREZ ID or Ensembl ID.It will be more convince for new users. Avaliable databases includes database_GO_BP(), database_GO_CC(), database_GO_MF() and database_Reactome().You can add more database by downloading MsigDB (https://www.gsea-msigdb.org/gsea/msigdb/human/collections.jsp)’s GMT files. It can be load by using database_from_gmt(FILE_PATH).If you only have simple a table, you can also pass a data frame through this arguement. Of note, it should contains at least 2 coloumn (colnames(df) = c(“Terms”,“Genes)), the first is term names and the second are the corresponding genes. If you have term ids, you can add a ID column at the first column, and Terms becomes the second column and Genes the third.\np_adj_methods: one of “holm”, “hochberg”, “hommel”, “bonferroni”, “BH”, “BY”, “fdr”, “none”\np_val_cut_off: adjusted pvalue cutoff on enrichment tests to report\nbackground_genes: background genes. If missing, the all genes listed in the database\nmin_geneset_size: minimal size of genes annotated for testing\nmax_geneset_size: maximal size of genes annotated for testing\nmulti_cores: multi_cores (Experimental), only used when analysis a list of genes (multi-source or groups). Set to 0 or 1 to disable. May use lots of RAM."
  },
  {
    "objectID": "pkgfuns.html#author-2",
    "href": "pkgfuns.html#author-2",
    "title": "DESCRIPTION",
    "section": "Author",
    "text": "Author\nZhiming Ye"
  },
  {
    "objectID": "pkgfuns.html#value-3",
    "href": "pkgfuns.html#value-3",
    "title": "DESCRIPTION",
    "section": "Value",
    "text": "Value\na data frame with ORA results."
  },
  {
    "objectID": "pkgfuns.html#description-5",
    "href": "pkgfuns.html#description-5",
    "title": "DESCRIPTION",
    "section": "Description",
    "text": "Description\nA warpper of fgsea::fgsea(). GSEA is a computational method used to determine whether predefined gene sets (e.g., pathways, GO terms) are statistically enriched in a ranked list of genes. Unlike ORA, GSEA considers the entire gene list and focuses on the cumulative distribution of gene ranks to identify coordinated changes. The fgsea (https://github.com/ctlab/fgsea) package is an R tool that implements an accelerated version of GSEA. It uses precomputed statistical methods and efficient algorithms to dramatically speed up enrichment analysis, especially for large datasets."
  },
  {
    "objectID": "pkgfuns.html#usage-4",
    "href": "pkgfuns.html#usage-4",
    "title": "DESCRIPTION",
    "section": "Usage",
    "text": "Usage\nres &lt;- egt_gsea_analysis(genes = genes_with_weights(genes = DEG$genes, weights = DEG$log2FoldChange),\ndatabase = database_GO_BP())\n\nres &lt;- egt_gsea_analysis(genes = genes_with_weights(genes = PCA_res$genes,weights =PCA_res$PC1_loading),\ndatabase = database_from_gmt(\"MsigDB_Hallmark.gmt\"))"
  },
  {
    "objectID": "pkgfuns.html#arguments-4",
    "href": "pkgfuns.html#arguments-4",
    "title": "DESCRIPTION",
    "section": "Arguments",
    "text": "Arguments\n\ngenes: a named numeric vector, for example c(TP53=1.2,KRT15=1.1,IL1B=1.0,PMP22 = 0.5,FABP1 = -0.9, GLUT1 = -2).The number is the weight of each gene, can use the logFC form DEG analysis results instead. Also NMF or PCA’s loading can also be used.EnrichGT provides a genes_with_weights(genes,weights) function to build this numeric vector. Importantly, this vector should be !SORTED! for larger to smaller.\ndatabase: a database data frame, can contain 3 columns (ID, Pathway_Name, Genes) or just 2 columns (Pathway_Name, Genes). You can read a data frame and pass it through this or run database_GO_CC() to get them, see example.The ID column is not necessary. EnrichGT contains several databases, functions about databases are named starts with database_..., like database_GO_BP() or database_Reactome().The default gene in each database EnrichGT provided to input is GENE SYMBOL (like TP53, not 1256 or ENSG…), not ENTREZ ID or Ensembl ID. It will be more convince for new users.Avaliable databases includes database_GO_BP(), database_GO_CC(), database_GO_MF() and database_Reactome().You can add more database by downloading MsigDB (https://www.gsea-msigdb.org/gsea/msigdb/human/collections.jsp)’s GMT files. It can be load by using database_from_gmt(FILE_PATH).If you only have simple a table, you can also pass a data frame through this arguement. Of note, it should contains at least 2 coloumn (colnames(df) = c(“Terms”,“Genes)), the first is term names and the second are the corresponding genes. If you have term ids, you can add a ID column at the first column, and Terms becomes the second column and Genes the third.\np_val_cut_off: adjusted pvalue cutoff on enrichment tests to report\nmin_geneset_size: minimal size of genes annotated for testing\nmax_geneset_size: maximal size of genes annotated for testing\ngseaParam: other param passing to fgsea\np_adj_methods: one of “holm”, “hochberg”, “hommel”, “bonferroni”, “BH”, “BY”, “fdr”, “none”"
  },
  {
    "objectID": "pkgfuns.html#author-3",
    "href": "pkgfuns.html#author-3",
    "title": "DESCRIPTION",
    "section": "Author",
    "text": "Author\nwarpped from fgsea package."
  },
  {
    "objectID": "pkgfuns.html#value-4",
    "href": "pkgfuns.html#value-4",
    "title": "DESCRIPTION",
    "section": "Value",
    "text": "Value\na data frame"
  },
  {
    "objectID": "pkgfuns.html#description-6",
    "href": "pkgfuns.html#description-6",
    "title": "DESCRIPTION",
    "section": "Description",
    "text": "Description\nOnly supports gene symbols. so you must use enrichedObj |&gt; setReadable(OrgDb = xxx,keyType = “ENTREZID”) |&gt; EnrichGT() . Do Not supports ENTREZIDs! PROGENy is a comprehensive resource containing a curated collection of pathways and their target genes, with weights for each interaction. CollecTRI is a comprehensive resource containing a curated collection of TFs and their transcriptional targets compiled from 12 different resources. This collection provides an increased coverage of transcription factors and a superior performance in identifying perturbed TFs compared to our previous. If when doing re-enrichment, you select a high number of clusters, that may cause low gene number in each meta-gene module, and then can’t be infered sucessfully. So if result is empty, please increase the number of re-clustering when doing it."
  },
  {
    "objectID": "pkgfuns.html#usage-5",
    "href": "pkgfuns.html#usage-5",
    "title": "DESCRIPTION",
    "section": "Usage",
    "text": "Usage\negt_infer_act(x, DB = \"collectri\", species = \"human\")"
  },
  {
    "objectID": "pkgfuns.html#arguments-5",
    "href": "pkgfuns.html#arguments-5",
    "title": "DESCRIPTION",
    "section": "Arguments",
    "text": "Arguments\n\nx: an EnrichGT_obj object.\nDB: can be “progeny” (the Pathway activity database), or “collectri” (TF activity database)\nspecies: can be “human” or “mouse”"
  },
  {
    "objectID": "pkgfuns.html#author-4",
    "href": "pkgfuns.html#author-4",
    "title": "DESCRIPTION",
    "section": "Author",
    "text": "Author\nZhiming Ye, Saez-Rodriguez Lab (The decoupleR package, https://saezlab.github.io/decoupleR/)"
  },
  {
    "objectID": "pkgfuns.html#value-5",
    "href": "pkgfuns.html#value-5",
    "title": "DESCRIPTION",
    "section": "Value",
    "text": "Value\na compareCluster result from clusterProfiler"
  },
  {
    "objectID": "pkgfuns.html#description-7",
    "href": "pkgfuns.html#description-7",
    "title": "DESCRIPTION",
    "section": "Description",
    "text": "Description\nThis plot is the most widely like enrichplot::dotplot()used method to visualize enriched terms. It shows the enrichment scores (e.g. p values) and gene ratio or NES as dot size and color / or bar height. Users can specify the number of terms using ntop or selected terms to color via the low.col and hi.col."
  },
  {
    "objectID": "pkgfuns.html#usage-6",
    "href": "pkgfuns.html#usage-6",
    "title": "DESCRIPTION",
    "section": "Usage",
    "text": "Usage\negt_plot_results(x, ntop = 30, ..., P.adj = NULL)"
  },
  {
    "objectID": "pkgfuns.html#arguments-6",
    "href": "pkgfuns.html#arguments-6",
    "title": "DESCRIPTION",
    "section": "Arguments",
    "text": "Arguments\n\nx: a data frame form enriched result like egt_enrichment_analysis() or egt_gsea_analysis(), or an re-clustered EnrichGT object\nntop: Show top N in each cluster\n...: Other param\nP.adj: If pass an origin data.frame from original enriched result, you can specify the P-adjust value cut off. If is null, default is 0.05. When passing EnrichGT_obj, this filter is previously done by egt_recluster_analysis.\nlow.col: the color for the lowest\nhi.col: the color for the highest\nmax_len_descript: the label format length, default as 40."
  },
  {
    "objectID": "pkgfuns.html#author-5",
    "href": "pkgfuns.html#author-5",
    "title": "DESCRIPTION",
    "section": "Author",
    "text": "Author\nZhiming Ye"
  },
  {
    "objectID": "pkgfuns.html#value-6",
    "href": "pkgfuns.html#value-6",
    "title": "DESCRIPTION",
    "section": "Value",
    "text": "Value\na ggplot2 object"
  },
  {
    "objectID": "pkgfuns.html#description-8",
    "href": "pkgfuns.html#description-8",
    "title": "DESCRIPTION",
    "section": "Description",
    "text": "Description\nA word frequency matrix represents the frequency of words or tokens across different documents or text samples. Each row corresponds to a document, and each column represents a word or token, with the cell values indicating the frequency of the respective word in that document.However, high-dimensional data like word frequency matrices can be challenging to interpret directly. To make such data easier to analyze, we can reduce its dimensionality and visualize the patterns or clusters in a 2D or 3D space. UMAP (Uniform Manifold Approximation and Projection) is a powerful, non-linear dimensionality reduction technique widely used for this purpose."
  },
  {
    "objectID": "pkgfuns.html#usage-7",
    "href": "pkgfuns.html#usage-7",
    "title": "DESCRIPTION",
    "section": "Usage",
    "text": "Usage\negt_plot_umap(x, ...)"
  },
  {
    "objectID": "pkgfuns.html#arguments-7",
    "href": "pkgfuns.html#arguments-7",
    "title": "DESCRIPTION",
    "section": "Arguments",
    "text": "Arguments\n\nx: an EnrichGT object\n...: Other param"
  },
  {
    "objectID": "pkgfuns.html#author-6",
    "href": "pkgfuns.html#author-6",
    "title": "DESCRIPTION",
    "section": "Author",
    "text": "Author\nZhiming Ye"
  },
  {
    "objectID": "pkgfuns.html#value-7",
    "href": "pkgfuns.html#value-7",
    "title": "DESCRIPTION",
    "section": "Value",
    "text": "Value\na ggplot2 object"
  },
  {
    "objectID": "pkgfuns.html#description-9",
    "href": "pkgfuns.html#description-9",
    "title": "DESCRIPTION",
    "section": "Description",
    "text": "Description\nCluster enrichment results based on hit genes for ORA (e.g, typical GO enrichment) or core enrichment from GSEA using term frequency analysis. This provides a clearer view of biological relevance by focusing on the genes that matter most. Gene enrichment analysis can often be misleading due to the redundancy within gene set databases and the limitations of most enrichment tools. Many tools, by default, only display a few top results and fail to filter out redundancy. This can result in both biological misinterpretation and valuable information being overlooked. For instance, high expression of certain immune genes can cause many immune-related gene sets to appear overrepresented. However, a closer look often reveals that these gene sets are derived from the same group of genes, which might represent only a small fraction. Less than 1/10 of the differentially expressed genes (DEGs). What about the other 9/10? Do they hold no biological significance? The main purpose of developing this package is to provide a lightweight and practical solution to the problems mentioned above."
  },
  {
    "objectID": "pkgfuns.html#usage-8",
    "href": "pkgfuns.html#usage-8",
    "title": "DESCRIPTION",
    "section": "Usage",
    "text": "Usage\negt_recluster_analysis(\n  x,\n  ClusterNum = 17,\n  P.adj = 0.05,\n  force = F,\n  nTop = 10,\n  method = \"ward.D2\",\n  ...\n)"
  },
  {
    "objectID": "pkgfuns.html#arguments-8",
    "href": "pkgfuns.html#arguments-8",
    "title": "DESCRIPTION",
    "section": "Arguments",
    "text": "Arguments\n\nx: an enrichment result from clusterProfiler, or a data.frame containing result from clusterProfier. To perform fusing multi-database enrichment results, please give a list object.\nClusterNum: how many cluster will be clustered\nP.adj: p.adjust cut-off. To avoid slow visualization, you can make stricter p-cut off.\nforce: ignore all auto-self-checks, which is useful\nnTop: keep n top items according to p-adj in each cluster.\nmethod: the agglomeration method to be used. This should be (an unambiguous abbreviation of) one of “ward.D”, “ward.D2”, “single”, “complete”, “average” (= UPGMA), “mcquitty” (= WPGMA), “median” (= WPGMC) or “centroid” (= UPGMC).\n...: Others options."
  },
  {
    "objectID": "pkgfuns.html#details-1",
    "href": "pkgfuns.html#details-1",
    "title": "DESCRIPTION",
    "section": "Details",
    "text": "Details\nFor an ORA result, c(“ID”,“Description”,“GeneRatio”,“pvalue”,“p.adjust”,“geneID”,“Count”) should be contained; For GSEA, c(“ID”,“Description”,“NES”,“pvalue”,“p.adjust”,“core_enrichment”) should be contain. For compareClusterResult, a compareClusterResult object or a data-frame with additional Cluster column should be contained, others similar to ORA result. To perform fusing multi-database enrichment results, please give a list object."
  },
  {
    "objectID": "pkgfuns.html#author-7",
    "href": "pkgfuns.html#author-7",
    "title": "DESCRIPTION",
    "section": "Author",
    "text": "Author\nZhiming Ye"
  },
  {
    "objectID": "pkgfuns.html#value-8",
    "href": "pkgfuns.html#value-8",
    "title": "DESCRIPTION",
    "section": "Value",
    "text": "Value\nan EnrichGT_obj object. slot enriched_result contains a data.frame with enriched results. gt_object contains gt object. you can use obj@gt_object to get it and use functions from gt like gtsave. gene_modules is a list containing meta-gene modules of each cluster. pathway_clusters contains pathways names in each cluster. clustering_tree contains the clustering tree object from hclust(), you can use other packages like ggtree for further visualization and analysis. raw_enriched_result contains raw table without selecting nTop."
  },
  {
    "objectID": "pkgfuns.html#description-10",
    "href": "pkgfuns.html#description-10",
    "title": "DESCRIPTION",
    "section": "Description",
    "text": "Description\nReturn ranked gene list which is use for “GSEA” or other places"
  },
  {
    "objectID": "pkgfuns.html#usage-9",
    "href": "pkgfuns.html#usage-9",
    "title": "DESCRIPTION",
    "section": "Usage",
    "text": "Usage\ngenes_with_weights(genes, weights)"
  },
  {
    "objectID": "pkgfuns.html#arguments-9",
    "href": "pkgfuns.html#arguments-9",
    "title": "DESCRIPTION",
    "section": "Arguments",
    "text": "Arguments\n\ngenes: A vector containing genes\nweights: A vector contain weight of genes, typically like log2FC from DEG analysis"
  },
  {
    "objectID": "pkgfuns.html#author-8",
    "href": "pkgfuns.html#author-8",
    "title": "DESCRIPTION",
    "section": "Author",
    "text": "Author\nZhiming Ye"
  },
  {
    "objectID": "pkgfuns.html#value-9",
    "href": "pkgfuns.html#value-9",
    "title": "DESCRIPTION",
    "section": "Value",
    "text": "Value\nA ranked named numeric vector. Names of the numbers is the ENTREZID."
  },
  {
    "objectID": "pkgfuns.html#description-11",
    "href": "pkgfuns.html#description-11",
    "title": "DESCRIPTION",
    "section": "Description",
    "text": "Description\nGet Gene Ontology (GO), Reactome, and other term-to-gene database, for enrichment analysis"
  },
  {
    "objectID": "pkgfuns.html#usage-10",
    "href": "pkgfuns.html#usage-10",
    "title": "DESCRIPTION",
    "section": "Usage",
    "text": "Usage\ndatabase_GO_BP(OrgDB = org.Hs.eg.db)\n\ndatabase_GO_CC(OrgDB = org.Hs.eg.db)\n\ndatabase_GO_MF(OrgDB = org.Hs.eg.db)\n\ndatabase_GO_ALL(OrgDB = org.Hs.eg.db)\n\ndatabase_Reactome(OrgDB = org.Hs.eg.db)\n\ndatabase_progeny_human()\n\ndatabase_progeny_mouse()\n\ndatabase_CollecTRI_human()\n\ndatabase_CollecTRI_mouse()"
  },
  {
    "objectID": "pkgfuns.html#arguments-10",
    "href": "pkgfuns.html#arguments-10",
    "title": "DESCRIPTION",
    "section": "Arguments",
    "text": "Arguments\n\nOrgDB: The AnnotationDbi database to fetch pathway data and convert gene IDs to gene symbols. For human it would be org.Hs.eg.db, for mouse it would be org.Mm.eg.db. In AnnotationDbi there are many species, please search AnnotationDbi for other species annotation database. GO and Reactome should add this, progeny and collectri do not."
  },
  {
    "objectID": "pkgfuns.html#author-9",
    "href": "pkgfuns.html#author-9",
    "title": "DESCRIPTION",
    "section": "Author",
    "text": "Author\nZhiming Ye. Part of functions were inspired by clusterProfiler but with brand new implement."
  },
  {
    "objectID": "pkgfuns.html#value-10",
    "href": "pkgfuns.html#value-10",
    "title": "DESCRIPTION",
    "section": "Value",
    "text": "Value\na data.frame with ID, terms and genes"
  },
  {
    "objectID": "pkgfuns.html#description-12",
    "href": "pkgfuns.html#description-12",
    "title": "DESCRIPTION",
    "section": "Description",
    "text": "Description\nKEGG is a commercialized database. So EnrichGT can’t pre-cache them locally. You can use this function to fetch KEGG database pathways and modules."
  },
  {
    "objectID": "pkgfuns.html#usage-11",
    "href": "pkgfuns.html#usage-11",
    "title": "DESCRIPTION",
    "section": "Usage",
    "text": "Usage\ndatabase_kegg(kegg_organism=\"hsa\",OrgDB = org.Hs.eg.db,kegg_modules=F,local_cache=F)\n\ndatabase_kegg_show_organism()"
  },
  {
    "objectID": "pkgfuns.html#arguments-11",
    "href": "pkgfuns.html#arguments-11",
    "title": "DESCRIPTION",
    "section": "Arguments",
    "text": "Arguments\n\nkegg_organism: Determine which species data from KEGG will be fetch. For human, it would be hsa(in default); For mouse, it would be mmu. If you wants other species, see database_kegg_show_organism() for details.\nOrgDB: The AnnotationDbi database to convert KEGG gene ID to gene symbols. For human it would be org.Hs.eg.db, for mouse it would be org.Mm.eg.db. In AnnotationDbi there are many species, please search AnnotationDbi for other species annotation database.\nkegg_modules: If TRUE, returns KEGG module; If FALSE returns KEGG pathways. In default, this is setted to FALSE to get mouse commonly used KEGG pathways.\nlocal_cache: cache a copy in local working folder. It will be saved as a .enrichgt_cache file in working dictionary. The .enrichgt_cache is just a .rds file, feel free to read it using readRDS()."
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "EnrichGT",
    "section": "",
    "text": "What is EnrichGT?\n\n\n\n\n\n\n\n\n\nEnrichGT means enriching previously enriched results (\\(E^2_{\\text{enrich}}\\)) into great tables and more …\n\n\n\n\nEfficient C++-based functions for rapid enrichment analysis\n\n\nSimple input format, empowering non-pro users\n\n\nRe-clustering of enriched results provides clear and actionable insights\n\n\nUser-friendly HTML output that is easy to read and interpret\n\n\nDo a series of things just in ONE package\n\n\n\n\n\n\n\n\n\n\ngraph LR\n    \n    M[genes]\n    N[genes with weights]\n    \n    subgraph Enrichment Analysis\n        A[egt_enrichment_analysis]\n        B[egt_gsea_analysis]\n    end\n\n    subgraph Pathway Databases\n        D[database_* funcs]\n    end\n\n    subgraph Visualize results\n        P1[egt_plot_results]\n        P2[egt_plot_umap]\n    end\n\n    subgraph egt_recluster_analysis\n        K1[Pretty table]\n        CC[cluster modules]\n        MG[gene modules]\n    end\n\n    subgraph Pathway Act. and TF infer \n        \n        I[egt_infer]\n    end\n    \n    M --&gt; A\n    N --&gt; B\n    \n    D --&gt; A\n    D --&gt; B\n    \n    A --&gt; C[Enriched Result]\n    B --&gt; C\n\n    C --&gt; CC\n    C --&gt; MG\n\n    C --&gt; P1\n\n    CC --&gt; K1\n    MG --&gt; K1\n\n    CC --&gt; P1\n    CC --&gt; P2\n\n    MG --&gt; I\n\n\n\n\n\n\n\nThe functions from EnrichGT are starting with “egt_” or “database_”.\nAfter version 0.7.0 (2024-12-24), EnrichGT would be entering supported mode and perhaps without adding new functions. We want to keep this package lightweight with limited functions. If you need a tool that handles every detail, please use clusterProfiler instead. See Acknowledgement for details."
  },
  {
    "objectID": "index.html#core-function",
    "href": "index.html#core-function",
    "title": "EnrichGT",
    "section": "Core Function",
    "text": "Core Function\n\nEnrichment of genes\nThis is a C++ accelerated over representation analysis tool. The only things you need is your favourite gene symbols. If is all prepared, then load a database, run it!\n\n\n\n\n\n\nThe difference from other tools\n\n\n\n\n\nCompared to the most popular clusterProfiler, the functions of EnrichGT differ slightly. This is mainly to accommodate wet lab researchers. First, most beginners are confused by the default input of clusterProfiler, which is “ENTREZ ID.” Most people familiar with biology are used to Gene Symbols, and even Ensembl IDs are not widely known, let alone a series of seemingly random numbers. Therefore, EnrichGT uses Gene Symbol as the default input, seamlessly integrating with most downstream results from various companies, making it more suitable for non-experts in the lab.\nSecond, clusterProfiler outputs an S4 object, which may be too complex for beginners (this is no joke); whereas EnrichGT outputs a simple table. The time of non-experts is precious, so I made these two adjustments. The only downside is that the GSEA peak plot is difficult to generate, but in reality, we focus more on NES and p-values, and in this case, bar plots are more convincing.\nFurthermore, The pre-processing step of the hypergeometric test in EnrichGT’s ORA function (which determines overlap) is accelerated using hash tables in C++, making it over five times faster than clusterProfiler::enricher(), which is a pure R implementation.\n\n\n\nres &lt;- egt_enrichment_analysis(genes = DEGtable$Genes,\ndatabase = database_GO_BP(org.Hs.eg.db))\n\nres &lt;- egt_enrichment_analysis(genes = c(\"TP53\",\"CD169\",\"CD68\",\"CD163\",\n                                         \"You can add more genes\"),\ndatabase = database_Reactome(org.Hs.eg.db))\n\nres &lt;- egt_enrichment_analysis(genes = c(\"TP53\",\"CD169\",\"CD68\",\"CD163\",\n                                         \"You can add more genes\"),\ndatabase = database_from_gmt(\"MsigDB_Hallmark.gmt\"))\nNow, we load the necessary packages and example dataset, to provide you with an example.\n\nlibrary(dplyr)\nlibrary(tibble)\nlibrary(ggplot2)\nlibrary(org.Hs.eg.db)\nlibrary(gt)\nlibrary(EnrichGT)\nlibrary(readr)\nDEGexample &lt;- read_csv(\"./DEG.csv\")\nDEGexample_UpReg &lt;- DEGexample |&gt; dplyr::filter(pvalue&lt;0.05,log2FoldChange&gt;0.7)\n\nThen we start ORA:\n\nora_result &lt;- egt_enrichment_analysis(genes = DEGexample_UpReg$...1,database = database_GO_BP(org.Hs.eg.db))\n\n\n\n\n✔ success loaded database, time used : 17.9219570159912 sec.\n\n\n✔ Done ORA in 0.138438940048218 sec.\n\nora_result |&gt; as_tibble() # You don't need to call as_tibble, this is just for better printing\n\n# A tibble: 2,979 × 9\n   ID       Description GeneRatio BgRatio   pvalue p.adjust  qvalue geneID Count\n   &lt;chr&gt;    &lt;chr&gt;       &lt;chr&gt;     &lt;chr&gt;      &lt;dbl&gt;    &lt;dbl&gt;   &lt;dbl&gt; &lt;chr&gt;  &lt;int&gt;\n 1 GO:0035… synaptic t… 19/457    111/18… 2.06e-11  8.05e-8 8.41e-5 ATP1A…    19\n 2 GO:0051… regulation… 16/457    79/188… 5.74e-11  8.05e-8 8.41e-5 ATP1A…    16\n 3 GO:0050… modulation… 39/457    489/18… 7.26e-11  8.05e-8 8.41e-5 ACHE/…    39\n 4 GO:0099… regulation… 39/457    490/18… 7.71e-11  8.05e-8 8.41e-5 ACHE/…    39\n 5 GO:0050… synapse or… 36/457    483/18… 2.51e- 9  2.10e-6 1.11e-3 ACHE/…    36\n 6 GO:0048… regulation… 12/457    56/188… 7.50e- 9  4.18e-6 1.11e-3 APOE/…    12\n 7 GO:0007… mitotic sp… 11/457    46/188… 9.27e- 9  4.18e-6 1.11e-3 BIRC5…    11\n 8 GO:0071… mitotic sp… 11/457    46/188… 9.27e- 9  4.18e-6 1.11e-3 BIRC5…    11\n 9 GO:0071… spindle as… 11/457    46/188… 9.27e- 9  4.18e-6 1.11e-3 BIRC5…    11\n10 GO:0031… spindle ch… 11/457    47/188… 1.18e- 8  4.18e-6 1.11e-3 BIRC5…    11\n# ℹ 2,969 more rows\n\n\n\n\n\n\n\n\nHave many sources of genes?\n\n\n\nThis function also support many groups of genes, you can input a list.\n# For many groups of genes\nres &lt;- egt_enrichment_analysis(list(Macrophages=c(\"CD169\",\"CD68\",\"CD163\"),\nFibroblast=c(\"COL1A2\",\"COL1A3\"),\"You can add more groups\"),\n database = database_from_gmt(\"panglaoDB.gmt\"))\n\n\nFor visualize, see Ploting ORA result for details.\n\n\nEnrichment of weighted genes (GSEA)\nGenes with specific weights (e.g. the log2FC) can use GSEA method. It should input a pre-ranked geneset. This use C++ accelerated fgsea::fgsea() as backend, so it is also very fast.\nThis provides a quick display of NES, p-values, and leading-edge genes. This function uses the same backend as the industry-standard clusterProfiler (it is also implemented using the fgsea package). However, EnrichGT does not delve as deeply as clusterProfiler and lacks advanced visualization capabilities. While it may not be sufficient for bioinformatics experts, the current implementation is adequate for wet-lab researchers. If comprehensive analysis is required, consider using clusterProfiler. However, if you only need an overview and reclustering, EnrichGT may be enough.\n\n\n\n\n\n\nHow to build pre-ranked gene set?\n\n\n\ngenes_with_weights(genes,weights) function is used to build the pre-ranked gene set for GSEA analysis.\n\n\nUsually, GSEA use the log2FoldChange from DEG analysis as the weights of genes. This is an example:\n\nresGSEA &lt;- egt_gsea_analysis(genes = \n                           genes_with_weights(genes = DEGexample$...1, \n                                              weights = DEGexample$log2FoldChange),\n                         database = database_GO_BP(org.Hs.eg.db)\n                         )\n\n✔ Use cached database: GO_BP_org.Hs.eg.db\n\n\nWarning in preparePathwaysAndStats(pathways, stats, minSize, maxSize, gseaParam, : There are ties in the preranked stats (0.02% of the list).\nThe order of those tied genes will be arbitrary, which may produce unexpected results.\n\n\n✔ Sucessful GSEA, time last 8.16707611083984 secs.\n\nresGSEA |&gt; as_tibble() # You don't need to call as_tibble, this is just for better printing\n\n# A tibble: 3,823 × 7\n   ID         Description              ES   NES  pvalue p.adjust core_enrichment\n   &lt;chr&gt;      &lt;chr&gt;                 &lt;dbl&gt; &lt;dbl&gt;   &lt;dbl&gt;    &lt;dbl&gt; &lt;chr&gt;          \n 1 GO:0060078 regulation of postsy… 0.564  1.94 6.34e-6 0.000240 GRIK3/HCN1/GRM…\n 2 GO:0050907 detection of chemica… 0.767  1.92 1.32e-4 0.00301  OR51E1/CST1/OR…\n 3 GO:0035249 synaptic transmissio… 0.560  1.91 1.70e-5 0.000562 GRIK3/UNC13C/G…\n 4 GO:0007216 G protein-coupled gl… 0.840  1.91 1.58e-4 0.00342  GRIK3/GRM1/GRM…\n 5 GO:0050906 detection of stimulu… 0.594  1.90 6.25e-5 0.00164  OR51E1/CST1/OR…\n 6 GO:0051966 regulation of synapt… 0.581  1.87 7.54e-5 0.00193  GRIK3/GRM1/CAC…\n 7 GO:0007628 adult walking behavi… 0.717  1.87 3.85e-4 0.00657  ZIC1/CNTN2/CAC…\n 8 GO:0061982 meiosis I cell cycle… 0.553  1.86 4.32e-5 0.00124  SPATA22/KASH5/…\n 9 GO:0045132 meiotic chromosome s… 0.587  1.86 1.55e-4 0.00339  SPATA22/KASH5/…\n10 GO:0035235 ionotropic glutamate… 0.718  1.84 5.92e-4 0.00882  GRIK3/GRIA4/GR…\n# ℹ 3,813 more rows\n\n\nOther kind of weights, like the loading from PCA or NMF, or the importance of random forest, can be also used.\nresExample &lt;- egt_gsea_analysis(genes = genes_with_weights(genes = PCA_res$genes,\n                                                    weights =PCA_res$PC1_loading),\n                         database = database_from_gmt(\"MsigDB_Hallmark.gmt\")\n                         )\nFor visualize, see Ploting GSEA result for details."
  },
  {
    "objectID": "index.html#re-enrich-function",
    "href": "index.html#re-enrich-function",
    "title": "EnrichGT",
    "section": "Re-ENRICH Function",
    "text": "Re-ENRICH Function\n\nEnrichment of Enriched Results\nThe enriched result is too messy? Clean up it!\nEnrichGT generates insightful results by simply constructing a term frequency matrix of genes enriched in pathways and performing clustering. While the results may not be statistically optimal, they offer significant interpretive insights.\nPrint ?egt_recluster_analysis for further help. But of note, you can adjust ClusterNum (Cluster the enrichment into N clusters) and nTop (Show how many top items in GT table) for a better result (the default is not all the best for your data).\n\n\n\n\n\n\nForm clusterProfiler ?\n\n\n\nThis can also supports the results from clusterProfiler, so you can use any tool to do this.\n\n\n\n\n\n\n\n\nWhy the re-enrichment is necessary?\n\n\n\n\n\n\nChallenges in Biological Gene Enrichment Analysis\nGene enrichment analysis can often be misleading due to the redundancy within gene set databases and the limitations of most enrichment tools. Many tools, by default, only display a few top results and fail to filter out redundancy. This can result in both biological misinterpretation and valuable information being overlooked.\nFor instance, high expression of certain immune genes can cause many immune-related gene sets to appear overrepresented. However, a closer look often reveals that these gene sets are derived from the same group of genes, which might represent only a small fraction (less than 10%) of the differentially expressed genes (DEGs). What about the other 90%? Do they hold no biological significance?\n\n\nCurrent Solutions\nclusterProfiler is one of the most powerful tools in R for enrichment analysis. It’s designed with pathway redundancy in mind and includes the clusterProfiler::simplify function to address this issue. This method, based on GOSemSim for GO similarity evaluation, is scientifically robust and highly effective.\nHowever, there are some drawbacks:\n\nGOSemSim is not fast, particularly when dealing with large or complex gene sets.\nIt doesn’t support databases like KEGG or Reactome.\n\nUsing GOSemSim to measure the semantic similarity between pathways is, theoretically, the best way to tackle redundancy. However, in practical cases—especially in experimental bioinformatics validation—researchers are more focused on the genes behind these pathways rather than the pathways themselves.\n\n\nAlternative Approaches\nAlthough clustering pathways based on gene overlap has received some criticism, it remains a viable approach in many situations. For this reason, I developed BioThemeFinder a few years ago to solve this problem. However, the tool is so awful (I am poor in coding…)\nToday, two excellent alternatives exist:\n\nsimplifyEnrichment: This package is more scientifically rigorous (based on semantic similarity) and creates beautiful visualizations. It also doesn’t support databases like KEGG or Reactome.\naPEAR: A simpler and faster tool that better aligns with practical needs, making it my preferred choice.\n\nHowever, both of these tools have a common limitation: their visualizations are optimized for publication purposes rather than for exploratory research. I often find myself exporting CSV files or struggling with RStudio’s preview pane to fully explore enrichment tables. This inspired me to develop a more efficient solution. Also, they are slow.\n\n\nGoals of This Package\nThe main purpose of developing this package is to provide a lightweight and practical solution to the problems mentioned above. Specifically, this package aims to:\nCluster enrichment results based on hit genes or core enrichment from GSEA using term frequency analysis (from the output of the powerful clusterProfiler). This provides a clearer view of biological relevance by focusing on the genes that matter most.\n\n\n\n\n# From results generated before\nres &lt;- egt_enrichment_analysis(genes = DEGtable$Genes,\ndatabase = database_GO_BP(Org.Hs.eg.db))\n\nre_enrich &lt;- egt_recluster_analysis(\n  res,\n  ClusterNum = 17,\n  P.adj = 0.05,\n  force = F,\n  nTop = 10,\n  method = \"ward.D2\"\n)\nYou can see the structure of re_enrich object above. The re_enrich object is an S4 EnrichGT_obj object. The first slot is the result table (a data.frame), and the second slot contains gt table.\n\nstr(re_enrich,max.level = 2)\n\nFormal class 'EnrichGT_obj' [package \"EnrichGT\"] with 7 slots\n  ..@ enriched_result     : tibble [103 × 7] (S3: tbl_df/tbl/data.frame)\n  ..@ gt_object           :List of 17\n  .. ..- attr(*, \"class\")= chr [1:2] \"gt_tbl\" \"list\"\n  ..@ gene_modules        :List of 16\n  ..@ pathway_clusters    :List of 16\n  ..@ document_term_matrix:Formal class 'dgCMatrix' [package \"Matrix\"] with 6 slots\n  ..@ clustering_tree     :List of 7\n  .. ..- attr(*, \"class\")= chr \"hclust\"\n  ..@ raw_enriched_result :'data.frame':    175 obs. of  7 variables:\n\n\n\n\n\n\n\n\nHow to get objects inside the S4 object?\n\n\n\nYou can use @, for example, x &lt;- re_enrich@enriched_result returns a result table and x &lt;- re_enrich@gt_object returns a gt object.\n\n\nYou can simple View(re_enrich@enriched_result) for the first slot.\n\nx &lt;- re_enrich@enriched_result # Get the re-enrichment result table\ntable(x$Cluster) # You can see all enriched results splited into 17 clusters\n\n\n Cluster_1 Cluster_10 Cluster_11 Cluster_12 Cluster_13 Cluster_14 Cluster_15 \n        10          4          3          5          2          1          4 \nCluster_16  Cluster_2  Cluster_3  Cluster_4  Cluster_5  Cluster_6  Cluster_7 \n         3         10         10         10         10         10         10 \n Cluster_8  Cluster_9 \n         7          4 \n\nx\n\n# A tibble: 103 × 7\n   Description                          ID    Count Cluster   PCT    Padj geneID\n   &lt;chr&gt;                                &lt;chr&gt; &lt;int&gt; &lt;chr&gt;   &lt;dbl&gt;   &lt;dbl&gt; &lt;chr&gt; \n 1 synaptic transmission, glutamatergic GO:0…    19 Cluste…   4.2 8.10e-8 ATP1A…\n 2 regulation of synaptic transmission… GO:0…    16 Cluste…   3.5 8.10e-8 ATP1A…\n 3 modulation of chemical synaptic tra… GO:0…    39 Cluste…   8.5 8.10e-8 ACHE,…\n 4 regulation of trans-synaptic signal… GO:0…    39 Cluste…   8.5 8.10e-8 ACHE,…\n 5 regulation of neuronal synaptic pla… GO:0…    12 Cluste…   2.6 4.20e-6 APOE,…\n 6 glutamate receptor signaling pathway GO:0…    11 Cluste…   2.4 5.20e-6 GRIA4…\n 7 ionotropic glutamate receptor signa… GO:0…     8 Cluste…   1.8 1.10e-5 GRIA4…\n 8 regulation of synaptic plasticity    GO:0…    20 Cluste…   4.4 4.50e-5 APOE,…\n 9 regulation of postsynaptic membrane… GO:0…    16 Cluste…   3.5 8.5 e-5 GABRD…\n10 ligand-gated ion channel signaling … GO:1…     8 Cluste…   1.8 1.2 e-4 GRIA4…\n# ℹ 93 more rows\n\n\nBut EnrichGT offers more than data frames. Please see HTML reports (gt table) for further visualization.\n\n\nInfering TFs or pathway activity and more based on meta-gene modules\nBased on re-enriched result, the S4 object return from re-enrichment contains gene_modules slot and pathway_clusters slot. In gene_modules slot you can find a group of meta-genes take part in specific pathway cluster (in pathway_clusters slot).\nEnrichGT supports inferring Pathway or Transcript Factors activity from re-enriched meta-gene modules. This is accomplished by two amazing database:\n\nPROGENy is a comprehensive resource containing a curated collection of pathways and their target genes, with weights for each interaction.\nCollecTRI is a comprehensive resource containing a curated collection of TFs and their transcriptional targets compiled from 12 different resources. This collection provides an increased coverage of transcription factors and a superior performance in identifying perturbed TFs compared to our previous.\n\n\n\n\n\n\n\nTF infering Example:\n\n\n\n\n\n\nre_enrich_smaller_clusterNum &lt;- \n  egt_recluster_analysis(\n  ora_result,\n  ClusterNum = 6, # reduce the cluster nums. \n  P.adj = 0.05,\n  force = F,\n  nTop = 10,\n  method = \"ward.D2\"\n)\nTF_Act &lt;- egt_infer_act(re_enrich_smaller_clusterNum,DB = \"collectri\", species = \"human\")\n\n! If when doing re-enrichment, you select a high number of clusters, that may cause low gene number in each meta-gene module, and then can't be infered sucessfully. So if result is empty, please increase the number of re-clustering when doing it. \n\n\n✔ success loaded self-contained database\n\n\n✔ Done ORA in 0.0144979953765869 sec.\n\n\n✔ Done ORA in 0.0141808986663818 sec.\n\n\n✔ Done ORA in 0.0157899856567383 sec.\n\n\n✔ Done ORA in 0.0157608985900879 sec.\n\n\n✔ Done ORA in 0.0171198844909668 sec.\n\n\n✔ Done ORA in 0.0142068862915039 sec.\n\negt_plot_results(TF_Act$Cluster_3)\n\nℹ Use Default P-adjust cut-off 0.05. You can pass `P.adj=xxx` arugument to filter. \n\n\n! You are drawing origin results, for better result you can re-cluster it by egt_recluster_analysis()\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nWants to interpret the regulator of whole inputted genes?\n\n\n\nPROGENy and CollecTRI can be used just like other database in ORA or GSEA enrichment, for example, the database_GO_BP(). See Progeny Database and CollecTRI Database page for detail.\nExample:\nTFActivity &lt;- egt_enrichment_analysis(genes = DEGtable$Genes,\ndatabase = database_CollecTRI_human())\n\n\n\n\n\n\n\n\nWhy many inferred results are empty?\n\n\n\nIf when doing re-enrichment with a high number of clusters, that may cause low gene number in each meta-gene module (splitting into too many clusters make gene in each cluster is not enough to enrich), and then can’t be inferred successfully. So if result is empty, please increase the number of re-clustering when doing it."
  },
  {
    "objectID": "index.html#functions-to-fusing-results",
    "href": "index.html#functions-to-fusing-results",
    "title": "EnrichGT",
    "section": "Functions to FUSING results",
    "text": "Functions to FUSING results\n\nEnrichment analysis using multiple databases\nSome enrichment analysis tools like Metascape can provide multi-database analysis in one-click (e.g. combining GO, KEGG, Reactome… ). EnrichGT also provides a similar function to achieve this (fuse them). You can provide a list containing multiple enrichment results form EnrichGT or clusterProfiler into egt_recluster_analysis.\n\n\n\n\n\n\nImportant\n\n\n\nOf note, all enriched objects in the same list should from the same gene source. Like the below example, both the res1 and res2 are enriched results from DEGtable$Genes.\n\n\nExample:\nres1 &lt;- egt_enrichment_analysis(genes = DEGtable$Genes,\ndatabase = database_GO_BP(org.Hs.eg.db))\n\nres2 &lt;- egt_enrichment_analysis(genes = DEGtable$Genes,\ndatabase = database_Reactome(org.Hs.eg.db))\n\nFused_enrich &lt;- egt_recluster_analysis(list(res1,res2))\nAfter this, you can generate HTML tables to view the fused result (See the HTML reports (gt table)).\n\n\nReversed gene sources analyzed by same database\nThis is a less meticulously crafted feature that performs re-clustering analysis by categorizing and considering various cases, such as intersections, unions, and unrelated sets. The result is a list containing four EnrichGT_obj objects with overlapped enriched terms, unique enrich terms.\n# See ?egt_compare_groups for further helps\nResult_List &lt;- egt_compare_groups(\n  obj.test,\n  obj.ctrl,\n  name.test = NULL,\n  name.ctrl = NULL,\n  ClusterNum = 15,\n  P.adj = 0.05,\n  force = F,\n  nTop = 10,\n  method = \"ward.D2\",\n)\nExample:\n\nDEGexample_UpReg &lt;- DEGexample |&gt; dplyr::filter(pvalue&lt;0.05,log2FoldChange&gt;0.7)\nDEGexample_DownReg &lt;- DEGexample |&gt; dplyr::filter(pvalue&lt;0.05,log2FoldChange&lt;(-0.7))\nora_resultUP &lt;- egt_enrichment_analysis(genes = DEGexample_UpReg$...1,database = database_GO_BP(org.Hs.eg.db))\nora_resultDown &lt;- egt_enrichment_analysis(genes = DEGexample_DownReg$...1,database = database_GO_BP(org.Hs.eg.db))\nCompared_Result &lt;- egt_compare_groups(ora_resultUP,ora_resultDown)\n\nYou can use str(Result_List) to explore what is inside the list. All items inside it is all basic EnrichGT_objs. You can then use the functions from other sections of this tutorial for similar visualizations.\n\nstr(Compared_Result,max.level = 2)\n\nList of 4\n $ Overlap_Control:Formal class 'EnrichGT_obj' [package \"EnrichGT\"] with 7 slots\n $ Overlap_Test   :Formal class 'EnrichGT_obj' [package \"EnrichGT\"] with 7 slots\n $ Control_Only   :Formal class 'EnrichGT_obj' [package \"EnrichGT\"] with 7 slots\n $ Test_Only      :Formal class 'EnrichGT_obj' [package \"EnrichGT\"] with 7 slots"
  },
  {
    "objectID": "index.html#html-reports-gt-table",
    "href": "index.html#html-reports-gt-table",
    "title": "EnrichGT",
    "section": "HTML reports (gt table)",
    "text": "HTML reports (gt table)\nBecause of the messy result table is hardly to read, EnrichGT help you convert it into pretty gt HTML tables. This only supports the re-enriched results.\nYou can simple input the object name of re-enriched object or fused object, to show the table.\n\nThis just shows the second slot inside the EnrichGT_obj object. The second slot - gt_object is a pure object of gt package, you can use any function on it, like:\nre_enrichment_results@gt_object |&gt; gt_save(\"test.html\") # Save it use basic gt functions. \nFor further usage of gt package, please refer to https://gt.rstudio.com/articles/gt.html.\nSee re-enrichment example for further demo."
  },
  {
    "objectID": "index.html#ploting-functions",
    "href": "index.html#ploting-functions",
    "title": "EnrichGT",
    "section": "Ploting functions",
    "text": "Ploting functions\nHTML gt table satisfied most of things, but for others. Though we don’t want this package become complex (i.e., you can simple draw your figure using ggplot2 for enriched tables by yourself.) But we still provide limited figure ploting functions.\n\nBasic result plot\nThe Dot Plot provide basic viewing of results. So it supports both simple enrichment result data.frame and re-enriched egt_object.\n\nPloting ORA result\n\negt_plot_results(ora_result)\n\nℹ Use Default P-adjust cut-off 0.05. You can pass `P.adj=xxx` arugument to filter. \n\n\n! You are drawing origin results, for better result you can re-cluster it by egt_recluster_analysis()\n\n\n\n\n\n\n\n\n\n\n\nPloting GSEA result\n\negt_plot_results(resGSEA)\n\nℹ Use Default P-adjust cut-off 0.05. You can pass `P.adj=xxx` arugument to filter. \n\n\n! You are drawing origin results, for better result you can re-cluster it by egt_recluster_analysis()\n\n\n\n\n\n\n\n\n\n\n\nPloting re-enrichment result\n\negt_plot_results(re_enrich)\n\n\n\n\n\n\n\n\n\n\n\nRe-enrichment dimensionality reduction plot\nUMAP plot only supports re-enriched egt_object, to show the dimensionality reduction view of enriched results.\n\negt_plot_umap(re_enrich)\n\nWarning: ggrepel: 19 unlabeled data points (too many overlaps). Consider\nincreasing max.overlaps"
  },
  {
    "objectID": "index.html#databases-helpers",
    "href": "index.html#databases-helpers",
    "title": "EnrichGT",
    "section": "DataBases Helpers",
    "text": "DataBases Helpers\n\n\n\n\n\n\nHow to specify species?\n\n\n\nEnrichGT use AnnotationDbi for fetching most of databases and gene annotations. you can use org.Hs.eg.db for human and org.Mm.eg.db for mouse. For others, please search in Google or refer to BioConductor.\nBut for non-AnnotationDbi source database, you do not need to provide this, like database_CollecTRI_human() return database about human only.\n\n\n\nBuilt in database form AnnotationDbi\nYou should add argument OrgDB for fetching them.\nExample:\ndatabase_GO_BP(OrgDB = org.Hs.eg.db)\n\nGO Database\nBP stands for biological process, CC stands for cellular component and MF stands for molecular functions. The ALL will combined the above three sub-databases.\ndatabase_GO_BP(), database_GO_CC(), database_GO_MF(), database_GO_ALL()\n\n\nReactome Database\nReactome is an open source pathway database.\ndatabase_Reactome()\n\n\nKEGG Database\nKEGG is a commercialized database. So EnrichGT can’t pre-cache them locally. You can use database_kegg to fetch KEGG database pathways and modules.\nThis function requires two species-related argument. You may familiar to the OrgDB argument as they will be used to convert ENTREZ IDs to symbols like before. Another argument is the kegg_organism. It determines which species data from KEGG will be fetch. For human, it would be hsa(in default); For mouse, it would be mmu. If you wants other species, execute database_kegg_show_organism() for details.\nYou can switch fetching KEGG pathways or modules by argument kegg_modules. If TRUE, returns KEGG module; If FALSE returns KEGG pathways. In default, this is setted to FALSE to get mouse commonly used KEGG pathways.\nIf you set local_cache = T, EnrichGT will cache a copy in local working folder. It will be saved as a .enrichgt_cache file in working dictionary. The .enrichgt_cache is just a .rds file, feel free to read it using readRDS().\nkeggdf &lt;- database_kegg(kegg_organism=\"hsa\",OrgDB = org.Hs.eg.db,kegg_modules=F,local_cache=F)\n\n\nWikiPathway Database\nWikiPathway database provides pre-built GMT files (https://data.wikipathways.org/current/gmt/). In default they are recorded as ENTREZ IDs, so you need to provide proper species database (e.g. org.Hs.eg.db for human), to database_from_gmt function and EnrichGT will automatically convert ENTREZ IDs to gene symbols for enrichment analysis.\ndownload.file(\"https://data.wikipathways.org/current/gmt/wikipathways-20241210-gmt-Homo_sapiens.gmt\",destfile = \"WikiPWS_human.gmt\")\nWikiPWsDB &lt;- database_from_gmt(\"WikiPWS_human.gmt\",OrgDB=org.Hs.eg.db)\nres &lt;- egt_enrichment_analysis(genes = DEGtable$Genes,\ndatabase = WikiPWsDB)\n\n\nProgeny Database\nFor pathway activity infer, database_progeny_human() and database_progeny_mouse()\n\n\nCollecTRI Database\nFor Transcript Factors infer, database_CollecTRI_human() and database_CollecTRI_mouse()\n\n\n\nRead Addition Gene Sets from local GMT files\nEnrichGT supports reading GMT files, You can obtain GMT files from MsigDB.\ndatabase_from_gmt(\"Path_to_your_Gmt_file.gmt\")\nIn default, database_from_gmt will try to convert the numeric ids to gene symbols (as they are usually the ENTREZ IDs, you can disable this by passing convert_2_symbols = F ).\n\n\nRead Addition Gene Sets from local data tables\nThe result of any database_*** functions are data.frames. So you can simple read any data tables and use them for any enrichment function.\nThe typical input should be:\n\n\n\nIDs\nTerm\nGenes\n\n\n\n\nID1\nBiological Pathway1\nGene1, Gene2, Gene3…\n\n\nID2\nBiological Pathway2\nGene4, Gene2, Gene3…\n\n\n…\n…\n…\n\n\n\nor\n\n\n\nTerm\nGenes\n\n\n\n\nBiological Pathway1\nGene1, Gene2, Gene3…\n\n\nBiological Pathway2\nGene4, Gene2, Gene3…\n\n\n…\n…\n\n\n\nExample:\nlibrary(readr)\ndb &lt;- read_csv(\"you_gene_set.csv\")\nres &lt;- egt_enrichment_analysis(genes = DEGtable$Genes,\ndatabase = db)\n\n\nGene Annotation Converter\nYou can use convert_annotations_genes() to convert gene annotations from any keys to any keys.\nExample:\n\nconvert_annotations_genes(DEGexample_UpReg$...1[1:10], from_what=\"SYMBOL\", to_what=c(\"ENTREZID\",\"ENSEMBL\",\"GENENAME\"), OrgDB=org.Hs.eg.db)\n\n'select()' returned 1:1 mapping between keys and columns\n\n\n    SYMBOL ENTREZID         ENSEMBL\n1   MT-ND4     &lt;NA&gt;            &lt;NA&gt;\n2    VAMP8     8673 ENSG00000118640\n3   PLAAT4     5920 ENSG00000133321\n4   LGALS1     3956 ENSG00000100097\n5   MT-CYB     &lt;NA&gt;            &lt;NA&gt;\n6   ARRDC2    27106 ENSG00000105643\n7    IMPA2     3613 ENSG00000141401\n8     KRT7     3855 ENSG00000135480\n9   IGFBP7     3490 ENSG00000163453\n10 DYNC2I2    89891 ENSG00000119333\n                                       GENENAME\n1                                          &lt;NA&gt;\n2         vesicle associated membrane protein 8\n3         phospholipase A and acyltransferase 4\n4                                    galectin 1\n5                                          &lt;NA&gt;\n6                  arrestin domain containing 2\n7                    inositol monophosphatase 2\n8                                     keratin 7\n9  insulin like growth factor binding protein 7\n10                dynein 2 intermediate chain 2"
  }
]